imports
{
import Data.Maybe
}

{
type Map a b = [(a,b)]
}


data Core
    | Core tm :: Tm

attr Core
    syn core :: {Mod}

sem Core
    | Core  lhs.core = Mod @tm.t @tm.binds
            tm.env = []


attr Tm Tm_
    syn main :: {Exp}
    syn exp :: {Exp}
    syn binds use {++} {[]} :: {BindL}
    inh env :: {Map String Int}

sem Tm_
    |   HNat lhs.main = SExp (Int @i)
             lhs.exp  = SExp (Int @i)
             lhs.binds = []
    |   HVar lhs.main = SExp $ tmToSExp @lhs.env (HVar @x)
             lhs.exp  = SExp $ tmToSExp @lhs.env (HVar @x)
             lhs.binds = []
    |   HLam lhs.main = 
             lhs.t  = SExp (Int 2)
             lhs.binds = [Bind (Glob 1) @t1.t]
             t1.env = insert @lhs.env @x
    |   HApp lhs.t  = App (@t1.t) [fromExp @t2.t]
             lhs.binds = []
             t1.env = @lhs.env
             t2.env = @lhs.env
    |   HLet lhs.main = @t2.main
             lhs.t  = Let (Bind (Glob 0) @t1.t) @t2.t
             lhs.binds = Bind (Glob 0) @t1.t : @t1.binds ++ @t2.binds
             t1.env = @lhs.env
             t2.env = insert @lhs.env @x


{

tmToTm_ :: Tm -> Tm_
tmToTm_ (Tm pos t) = t

fromExp :: Exp -> SExp
fromExp (SExp s) = s 

tmToSExp :: Map String Int -> Tm_ -> SExp
tmToSExp map (HNat i) = Int i
tmToSExp map (HVar x) = Var (Loc 0 (lookup' map x))

getOffSet :: Map String Int -> Int
getOffSet xs = length xs

insert :: Map String Int -> String -> Map String Int
insert xs s = (s, getOffSet xs) : xs

lookup' :: Map String Int -> String -> Int
lookup' [] _ = error "Was not able to find it"
lookup' ((x,y):xy) s
    | x == s = y
    | otherwise = lookup' xy s

}
-------------------Syntax-----------------

{
data Ty = Prog
        | Interp
        | Comp
        | PlatF
        | Runnable
        | Framework
         deriving (Eq, Show)

instance Tree Ty where
    fromTree Prog = App "Prog" []
    fromTree Interp = App "Interp" []
    fromTree Comp = App "Comp" []
    fromTree PlatF = App "PlatF" []
    fromTree Runnable = App "Runnable" []
    fromTree Framework = App "Framework" []

    toTree = parseTree [ app "Prog" (pure Prog),
                         app "Interp" (pure Interp),
                         app "Comp" (pure Comp),
                         app "PlatF" (pure PlatF),
                         app "Runnable" (pure Runnable),
                         app "Framework" (pure Framework)
                       ]



match :: Ty -> Ty -> Bool
match Runnable Runnable = True
match Runnable _ = False
match Framework Framework = True
match Framework _ = False
match Prog Runnable = True
match Interp Runnable = True
match Comp Runnable = True
match Interp Framework = True
match PlatF Framework = True
match ty1 ty2 = ty1 == ty2



joinTypeInfo :: Diag_ -> Diag_ -> TypeInfo -> TypeInfo -> TypeInfo
joinTypeInfo (Execute _ _) (Execute _ _) (TypeInfo s1 m1) (TypeInfo s2 t2 m2) = TypeInfo (s1 ++ s2) (t1 ++ t2) (m1 ++ m2)
joinTypeInfo (Execute _ _) (Compile _ _) (TypeInfo s1 m1) (TypeInfo s2 t2 m2) = TypeInfo (s1 ++ s2) (t1 ++ t2) (m1 ++ m2)
joinTypeInfo (Execute _ _) d2 (TypeInfo s1 m1) (TypeInfo s2 t2 m2)            = TypeInfo (s1 ++ s2) (t1 ++ t2) (m1 ++ m2)
joinTypeInfo (Compile _ _) (Execute _ _) (TypeInfo s1 m1) (TypeInfo s2 t2 m2) = TypeInfo (s1 ++ s2) (t1 ++ t2) (m1 ++ m2)
joinTypeInfo (Compile _ _) (Compile _ _) (TypeInfo s1 m1) (TypeInfo s2 t2 m2) = TypeInfo (s1 ++ s2) (t1 ++ t2) (m1 ++ m2)
joinTypeInfo (Compile _ _) d2 (TypeInfo s1 m1) (TypeInfo s2 t2 m2)            = TypeInfo (s1 ++ s2) (t1 ++ t2) (m1 ++ m2)
joinTypeInfo d1 d2 (TypeInfo s1 t1 m1) (TypeInfo s2 t2 m2)                    = TypeInfo (s1 ++ s2) (t1 ++ t2) (m1 ++ m2)


}



-----------------------Typing-----------------
attr Diag Diag_
    syn ty :: {Ty}
    syn tyErrs use {++} {[]} :: {[TyErr]}
    syn tyInfo :: {TypeInfo}

sem Diag_
    | Program lhs.ty = Prog
    | Interpreter lhs.ty = Interp
    | Compiler lhs.ty = Comp
    | Platform lhs.ty = PlatF
    | Execute lhs.ty = @d1.ty
    | Compile lhs.ty = @d1.ty

sem Diag_
    | Program lhs.tyInfo = TypeInfo [@l] [] []
    | Interpreter lhs.tyInfo = TypeInfo [@l] [] [@m]
    | Compiler lhs.tyInfo = TypeInfo [@l1] [@l2] [@m]
    | Platform lhs.tyInfo = TypeInfo [] [] [@m]
    | Compile lhs.tyInfo = joinTypeInfo @d1 @d2 @d1.tyInfo @d2.tyInfo
    | Execute lhs.tyInfo = joinTypeInfo @d1.tyInfo @d2.tyInfo

sem Diag_
    | Execute lhs.tyErrs =  @d1.tyErrs ++ @d2.tyErrs ++
                            checkRunnable @d1.pos @d1.ty ++
                            checkFramework @d2.pos @d2.ty ++
                            checkLang @d1.pos @d1.ty @d2.ty

{
checkRunnable :: SourcePos -> Ty -> [TyErr]
checkRunnable _ ty | match ty Runnable = []
checkRunnable pos ty                   = [TyErr pos nonExe Runnable ty]
    where
        nonExe = "Cannot execute a non-runnable"

checkFramework :: SourcePos -> Ty -> [TyErr]
checkFramework _ ty | match ty Framework = []
checkFramework pos ty                    = [TyErr pos nonFrame Framework ty]
    where
        nonFrame = "Cannot execute on non-Framework"
}

sem Diag_
    | Compile lhs.tyErrs =  @d1.tyErrs ++ @d2.tyErrs ++
                            checkRunnable @d1.pos @d1.ty ++
                            checkComp @d2.pos @d2.ty

{
checkComp :: SourcePos -> Ty -> [TyErr]
checkComp _ ty | match ty Comp = []
checkComp pos ty               = [TyErr pos nonComp Comp ty]
    where
        nonComp = "Must be compiled using a compiler"

checkLang :: SourcePos -> Ty -> Ty -> [TyErr]
checkLang _ ty1 ty2 | match ty1 ty2 = []
checkLang pos ty1 ty2              = [TyErr pos nonExe Runnable ty1]
    where
        nonExe = "Does not belong to the correct language"
}

--------------------Type Info-------------------------
{
data TypeInfo = TypeInfo {source :: [Ident], target :: [Ident], platform :: [Ident]}
}


--------------------Type Errors-----------------------

{
data TyErr = TyErr SourcePos String Ty Ty

instance Printable TyErr where
    pp = ppTyErr
}

-----------------Print type errors--------------------
{
-- | Pretty prints a type error message.
ppTyErr :: TyErr -> Doc
ppTyErr (TyErr pos descr expected inferred)
  = above [ppHeader, text " ", ppExpected, ppInferred]
  where
    ppHeader   = wrapped $
                 describeSourcePos pos ++ ": Type error: " ++ descr ++ "."
    ppExpected = text "? expected : " >|< showable expected
    ppInferred = text "? inferred : " >|< showable inferred
}
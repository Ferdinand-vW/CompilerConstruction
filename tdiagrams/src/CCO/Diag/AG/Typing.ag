-------------------Syntax-----------------

{
data Ty = Prog Ident | Interp Ident Ident | Comp Ident Ident Ident | PlatF Ident | Runnable | Framework | Top deriving (Eq, Show)

instance Tree Ty where
    fromTree Prog = App "Prog" []
    fromTree Interp = App "Interp" []
    fromTree Comp = App "Comp" []
    fromTree PlatF = App "PlatF" []
    fromTree Runnable = App "Runnable" []
    fromTree Framework = App "Framework" []
    fromTree Top = App "Top" []

    toTree = parseTree [ app "Prog" (pure Prog),
                         app "Interp" (pure Interp),
                         app "Comp" (pure Comp),
                         app "PlatF" (pure PlatF),
                         app "Runnable" (pure Runnable),
                         app "Framework" (pure Framework),
                         app "Top" (pure Top)]

match :: Ty -> Ty -> Bool
match _ Top = False
match Top _ = False
match Runnable Prog = True
match Runnable Interp = True
match Runnable Comp = True
match Prog Runnable = True
match Interp Runnable = True
match Comp Runnable = True
match Framework Interp = True
match Framework PlatF = True
match Interp Framework = True
match PlatF Framework = True
match ty1 ty2 = ty1 == ty2


typeOfExecute :: Ty -> Ty -> Ty
typeOfExecute ty1 ty2
    | not (match ty1 PlatF) && (match ty2 PlatF || match ty2 Interp) = ty1
    | otherwise = Top

typeOfCompile :: Ty -> Ty -> Ty
typeOfCompile ty1 ty2
    | not (match ty1 PlatF) && (match ty2 Comp) = ty1
    | otherwise = Top

}



-----------------------Typing-----------------

attr Diag Diag_
    syn ty :: {Ty}
    syn tyErrs use {++} {[]} :: {[TyErr]}

sem Diag_
    | Program lhs.ty = Prog
    | Interpreter lhs.ty = Interp
    | Compiler lhs.ty = Comp
    | Platform lhs.ty = PlatF
    | Execute lhs.ty = typeOfExecute @d1.ty @d2.ty
    | Compile lhs.ty = typeOfCompile @d1.ty @d2.ty

sem Diag_
    | Execute lhs.tyErrs =  @d1.tyErrs ++ @d2.tyErrs ++
                            checkRunnable @d1.pos @d1.ty ++
                            checkFramework @d2.pos @d2.ty

{
checkRunnable :: SourcePos -> Ty -> [TyErr]
checkRunnable _ ty | match ty Runnable = []
checkRunnable pos ty                   = [TyErr pos nonExe Runnable ty]
    where
        nonExe = "Cannot execute a non-runnable"

checkFramework :: SourcePos -> Ty -> [TyErr]
checkFramework _ ty | match ty Framework = []
checkFramework pos ty                    = [TyErr pos nonFrame Framework ty]
    where
        nonFrame = "Cannot execute on non-Framework"
}

sem Diag_
    | Compile lhs.tyErrs =  @d1.tyErrs ++ @d2.tyErrs ++
                            checkRunnable @d1.pos @d1.ty ++
                            checkComp @d2.pos @d2.ty

{
checkComp :: SourcePos -> Ty -> [TyErr]
checkComp _ ty | match ty Comp = []
checkComp pos ty               = [TyErr pos nonComp Comp ty]
    where
        nonComp = "Must be compiled using a compiler"
}


--------------------Type Errors-----------------------

{
data TyErr = TyErr SourcePos String Ty Ty

instance Printable TyErr where
    pp = ppTyErr
}

-----------------Print type errors--------------------
{
-- | Pretty prints a type error message.
ppTyErr :: TyErr -> Doc
ppTyErr (TyErr pos descr expected inferred)
  = above [ppHeader, text " ", ppExpected, ppInferred]
  where
    ppHeader   = wrapped $
                 describeSourcePos pos ++ ": Type error: " ++ descr ++ "."
    ppExpected = text "? expected : " >|< showable expected
    ppInferred = text "? inferred : " >|< showable inferred
}
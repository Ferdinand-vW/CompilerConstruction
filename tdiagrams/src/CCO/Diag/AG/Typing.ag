-------------------Syntax-----------------

{
data TyCons = Prog
        | Interp
        | Comp
        | PlatF
        | Runnable
        | Framework
        | Executed
        | Compiled
        | Not_Executed
         deriving (Eq, Show)

data Ty = Ty {cons :: TyCons, source :: Maybe Ident, target :: Maybe Ident, platform :: Maybe Ident}deriving (Show, Eq)

show' :: Maybe String -> String
show' (Just x) = show x
show' Nothing  = ""   

instance Tree Ty where
    fromTree (Ty c s t p) = App "Ty" [fromTree c, fromTree s, fromTree t, fromTree p]
    toTree = parseTree [ app "Ty" (Ty <$> arg <*> arg <*> arg <*> arg)]

instance Tree TyCons where
    fromTree Prog = App "Prog" []
    fromTree Interp = App "Interp" []
    fromTree Comp = App "Comp" []
    fromTree PlatF = App "PlatF" []
    fromTree Runnable = App "Runnable" []
    fromTree Framework = App "Framework" []

    toTree = parseTree [ app "Prog" (pure Prog),
                         app "Interp" (pure Interp),
                         app "Comp" (pure Comp),
                         app "PlatF" (pure PlatF),
                         app "Runnable" (pure Runnable),
                         app "Framework" (pure Framework)
                       ]

match :: TyCons -> TyCons -> Bool
match Prog Runnable       = True
match Interp Runnable     = True
match Comp Runnable       = True
match Interp Framework    = True
match PlatF Framework     = True
match ty1 ty2             = ty1 == ty2 


matchInfo :: Maybe Ident -> Maybe Ident -> Bool
matchInfo (Just i) (Just j) = i == j
matchInfo _ _ = True

translate :: Ty -> Ty -> Ty
translate (Ty Prog s1 t1 m1) (Ty Comp s2 t2 m2)   = Ty Prog t2 t1 m1
translate (Ty Interp s1 t1 m1) (Ty Comp s2 t2 m2) = Ty Interp s1 t1 t2
translate (Ty Comp s1 t1 m1) (Ty Comp s2 t2 m2) = Ty Comp s1 t1 t2
translate tyinfo1 _ = tyinfo1

}



-----------------------Typing-----------------
attr Diag Diag_
    syn tycons :: {TyCons}
    syn ty :: {Ty}
    syn tyErrs use {++} {[]} :: {[TyErr]}

sem Diag_
    | Program lhs.ty =  Ty Prog (Just @l) Nothing Nothing
              lhs.tycons = Prog
    | Interpreter lhs.ty = Ty Interp (Just @l) Nothing (Just @m)
                  lhs.tycons = Interp
    | Compiler lhs.ty = Ty Comp (Just @l1) (Just @l2) (Just @m)
               lhs.tycons = Comp
    | Platform lhs.ty = Ty PlatF Nothing Nothing (Just @m)
               lhs.tycons = PlatF
    | Execute lhs.ty = @d2.ty
              lhs.tycons = Executed
    | Compile lhs.ty = translate @d1.ty @d2.ty
              lhs.tycons = Compiled


sem Diag_
    | Execute lhs.tyErrs =  @d1.tyErrs ++ @d2.tyErrs ++
                            checkRunnable @d1.pos (cons @d1.ty) ++
                            checkFramework @d2.pos (cons @d2.ty) ++
                            checkIfMatches @d1.pos @d1.ty @d2.ty ++
                            checkExeOrCompile @d2.pos @d2.tycons

{
checkRunnable :: SourcePos -> TyCons -> [TyErr]
checkRunnable pos ty | match ty Runnable = []
                     | otherwise          = [TyErr pos nonExe (show Runnable) (show ty)]
    where
        nonExe = "Cannot execute or compile a non-runnable"

checkFramework :: SourcePos -> TyCons -> [TyErr]
checkFramework pos ty | match ty Framework = []
                          | otherwise          = [TyErr pos nonFrame (show Framework) (show ty)]
    where
        nonFrame = "Cannot execute on non-Framework"

checkExeOrCompile :: SourcePos -> TyCons -> [TyErr]
checkExeOrCompile pos ty
    | match ty Executed || match ty Compiled = [TyErr pos descr (show Framework) (show ty)]
    | otherwise = []
    where
        descr = "Cannot execute runnable on a compilation or execution"
}

sem Diag_
    | Compile lhs.tyErrs =  @d1.tyErrs  ++ @d2.tyErrs ++
                            checkRunnable  @d1.pos (cons @d1.ty) ++
                            checkComp      @d2.pos (cons @d2.ty) ++
                            checkIfMatches @d1.pos @d1.ty @d2.ty ++
                            checkExeInCompile @d1.pos @d1.tycons ++
                            checkExeInCompile @d2.pos @d2.tycons

{
checkComp :: SourcePos -> TyCons -> [TyErr]
checkComp pos ty | match ty Comp = []
                 | otherwise = [TyErr pos nonComp (show Comp) (show ty)]
    where
        nonComp = "Must be compiled using a compiler"

checkExeInCompile :: SourcePos -> TyCons -> [TyErr]
checkExeInCompile pos ty | match ty Executed = [TyErr pos descr (show Not_Executed) (show ty)]
                         | otherwise = []
    where
        descr = "Cannot have an execution within a compilation"

checkIfMatches :: SourcePos -> Ty -> Ty -> [TyErr]
checkIfMatches pos (Ty Prog s1 _ m1) (Ty Interp s2 _ m2) | matchInfo s1 s2 = []
                                                         | otherwise = genTyInfoErr pos s1 s2
checkIfMatches pos (Ty _    s1 _ m1) (Ty Interp s2 _ m2) | matchInfo m1 s2 = []
                                                         | otherwise = genTyInfoErr pos m1 s2
checkIfMatches pos (Ty Prog s1 _ m1) (Ty PlatF  s2 _ m2) | matchInfo s1 m2 = []
                                                         | otherwise = genTyInfoErr pos s1 m2
checkIfMatches pos (Ty _    s1 _ m1) (Ty PlatF  s2 _ m2) | matchInfo m1 m2 = []
                                                         | otherwise = genTyInfoErr pos m1 m2
checkIfMatches pos (Ty Prog s1 _ m1) (Ty Comp   s2 _ m2) | matchInfo s1 s2 = []
                                                         | otherwise = genTyInfoErr pos s1 s2
checkIfMatches pos (Ty _    s1 _ m1) (Ty Comp   s2 _ m2) | matchInfo m1 s2 = []
                                                         | otherwise = genTyInfoErr pos m1 s2
checkIfMatches _ _ _ = [] --Type error has occurred so we cannot match type infos


genTyInfoErr :: SourcePos -> Maybe Ident -> Maybe Ident -> [TyErr]
genTyInfoErr pos mi mj = [TyErr pos descr (show' mi) (show' mj)]
    where
        descr = "Cannot execute or compile runnable on a non-matching platform or interpreter"
}

--------------------Type Errors-----------------------

{
data TyErr = TyErr SourcePos String String String

instance Printable TyErr where
    pp = ppTyErr
}

-----------------Print type errors--------------------
{
-- | Pretty prints a type error message.
ppTyErr :: TyErr -> Doc
ppTyErr (TyErr pos descr expected inferred)
  = ppErr "Type error" pos descr expected inferred

ppErr :: String -> SourcePos -> String -> String -> String -> Doc
ppErr msg pos descr a b =
    above [ppHeader, text " ", ppExpected, ppInferred]
    where
        ppHeader = wrapped $
                    describeSourcePos pos ++ ": " ++ msg ++ ": " ++ descr ++ "."
        ppExpected = text "? expected : " >|< text a
        ppInferred = text "? inferred : " >|< text b
}
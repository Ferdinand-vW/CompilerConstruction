----------------------------------------

  data Pic
    | Pic d :: Diag

attr Pic
  syn pic :: {Picture}

sem Pic
  | Pic lhs.pic = Picture (500,500) @d.cmd
         d.pos = (0,500)


attr Diag Diag_
    syn diag :: self
    syn cmd use {++} {[]} :: {[Command]}
    syn cjoint :: {(Double,Double)}
    syn ejoint :: {(Double,Double)}
    inh pos :: {(Double,Double)}


sem Diag_
    | Platform lhs.cmd = platform @lhs.pos @m
               lhs.ejoint = @lhs.pos
               lhs.cjoint = @lhs.pos
    | Program lhs.cmd = program @lhs.pos @p @l
              lhs.ejoint = eJoint @diag @lhs.pos
              lhs.cjoint = cJoint @diag @lhs.pos
    | Interpreter lhs.cmd = interpreter @lhs.pos @i @l @m
                  lhs.ejoint = eJoint @diag @lhs.pos
                  lhs.cjoint = cJoint @diag @lhs.pos
    | Compiler lhs.cmd = compiler @lhs.pos @c @l1 @l2 @m
               lhs.ejoint = eJoint @diag @lhs.pos
               lhs.cjoint = cJoint @diag @lhs.pos
    | Execute lhs.cmd = @d1.cmd ++ @d2.cmd
              lhs.cjoint = @d2.cjoint
              lhs.ejoint = @d2.ejoint
              d1.pos = @lhs.pos
              d2.pos = @d1.ejoint
    | Compile loc.cpos = (fst @d1.cjoint + (3 * 50), snd @d1.cjoint)
              loc.cmpl = compile (dtd_ @d1.diag) (dtd_ @d2.diag)
              lhs.cmd = @d1.cmd ++ @d2.cmd ++ compiled @loc.cmpl @loc.cpos
              lhs.cjoint = cJoint @loc.cmpl @loc.cpos
              lhs.ejoint = eJoint @loc.cmpl @loc.cpos
              d1.pos = @lhs.pos
              d2.pos = @d1.cjoint


{

type Position = (Double,Double)
--These are necessary, because we need to determine the ejoint and cjoint of the compiled
--diag, but as we then do not know what diag it is we have to do pattern matching.
eJoint :: Diag_ -> (Double,Double) -> (Double,Double)
eJoint (Program _ _) (x,y) = (x + 7.5, y - 30)
eJoint (Interpreter _ _ _) (x, y) = (x, y - 30)
eJoint (Compiler _ _ _ _) (x, y) = (fst pos + 50, snd pos - 30)

cJoint :: Diag_ -> (Double,Double) -> (Double,Double)
cJoint (Program _ _) (x, y) = (y + 57.5, y - 20)
cJoint (Interpreter _ _ _) (x, y) = (x + 50, y - 20)
cJoint (Compiler _ _ _ _) (x, y) = (x + 50, y - 20)

rightPos :: Diag_ -> Position -> Position
rightPos (Program _ _) (x, y) = (y + 57.5, y - 20)
rightPos (Interpreter _ _ _) (x, y) = (x + 50, y - 20)
rightPos (Compiler _ _ _ _) (x, y) = (x + 50, y - 20)

dtd_ :: Diag -> Diag_
dtd_ (Diag p d) = d

--First we still have to do some translation
compile :: Diag_ -> Diag_ -> Diag_
compile dg (Compile d1 d2) = compile dg (compile (dtd_ d1) (dtd_ d2))
compile (Program p _) (Compiler _ _ t _) = Program p t
compile (Interpreter i l _) (Compiler _ _ t _) = Interpreter i l t
compile (Compiler c l1 l2 _) (Compiler _ _ t _) = Compiler c l1 l2 t
compile (Execute d1 d2) dg = compile (dtd_ d2) dg
compile (Compile d1 d2) dg = compile (compile (dtd_ d1) (dtd_ d2)) dg
compile d1 _ = d1

--Given the translated diag and a position, convert it to a list of commands
compiled :: Diag_ -> (Double, Double) -> [Command]
compiled (Program p l) pos = program pos p l
compiled (Interpreter i l m) pos = interpreter pos i l m
compiled (Compiler c l1 l2 t) pos = compiler pos c l1 l2 t
compiled _ _ = []

platform :: (Double, Double) -> String -> [Command]
platform (x,y) m = [
            Put (x, y + 15) $ Line (5, -3) 25,
            Put (x + 25,y) $ Line (5, 3) 25,
            Put (x, y + 15) $ Line (0, 1) 15,
            Put (x, y + 30) $ Line (1, 0) 50,
            Put (x + 50, y + 30) $ Line (0,-1) 15,
            Put (x, y + 15) $ Makebox (50, 15) m
        ]

program ::  (Double, Double) ->  String -> String -> [Command]
program (x,y) p l = [
                Put (x + 7.5, y) $ Line (1,0) 50,
                Put (x + 7.5, y) $ Line (0,1) 15,
                Put (x + 7.5, y + 15) $ Line (-1, 2) 7.5,
                Put (x + 57.5, y + 15) $ Line (1, 2) 7.5,
                Put (x + 57.5, y) $ Line (0,1) 15,
                Put (x, y + 30) $ Line (1,0) 65,
                Put (x + 7.5, y + 15) $ Makebox (50, 15) p,
                Put (x + 7.5, y) $ Makebox (50, 15) l
            ]


interpreter :: (Double, Double) -> String -> String -> String -> [Command]
interpreter (x,y) i l m = [ 
                        Put (x, y) $ Framebox (50, 30) "", 
                        Put (x, y + 20) $ Makebox (50, 10) i,
                        Put (x, y + 10) $ Makebox (50, 10) l,
                        Put (x, y) $ Makebox (50,10) m
                    ]

compiler :: (Double, Double) -> String -> String -> String -> String -> [Command] 
compiler (x,y) c l1 l2 m = [
                        Put (x + 50, y) $ Line (0, 1) 20,
                        Put (x + 50, y + 20) $ Line (-1, 0) 50,
                        Put (x, y + 20) $ Line (0, 1) 10,
                        Put (x, y + 30) $ Line (1, 0) 150,
                        Put (x + 150, y + 30) $ Line (0,-1) 10,
                        Put (x + 150, y + 20) $ Line (-1,0) 50,
                        Put (x + 100, y + 20) $ Line (0,-1) 20,
                        Put (x + 100, y) $ Line (-1, 0) 50,
                        Put (x, y + 20) $ Makebox (50,10) l1,
                        Put (x + 50, y + 20) $ Makebox (50,10) "$\\longrightarrow$",
                        Put (x + 100, y + 20) $ Makebox (50,10) l2,
                        Put (x + 55, y + 10) $ Makebox (50,10) c,
                        Put (x + 50, y) $ Makebox (50,10) m
                    ]


}
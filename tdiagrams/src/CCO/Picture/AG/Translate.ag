----------------------------------------

data DiagCons
    | Plat
    | Interp
    | Comp
    | Prog

{
type Pos = (Double,Double)
type Ejoint = (Double, Double)
type Cjoint = (Double, Double)
type Height = Double
type Length = Double
type TotalLength = Double
type BlockLength = Double
type CompLength = Double
type Depth = Double

data DiagInfo = D {cons :: DiagCons, h :: Height, len :: Length, clen :: CompLength,
                   ejoint :: Ejoint, cjoint :: Cjoint}


{-

data DiagToPicture
  | Platform_ m :: {Ident}
  | Interpreter_ i :: {Ident} l :: {Ident} m :: {Ident}
  | Compiler_ c :: {Ident} l1 ::{Ident} l2 :: {Ident} m ::{Ident}
  | Program_ p :: {Ident} l :: {Ident}
  | Executed d1 :: DiagToPicture d2 :: DiagToPicture
  | Compiled d2 :: DiagToPicture d2 :: DiagToPicture d3 :: DiagToPicture

attr Diag Diag_
  syn diag2pic :: {DiagToPicture}

sem Diag_
  | Platform lhs.diag2pic = Platform_ @m
  | Interpreter lhs.diag2pic = Interpreter_ @i @l @m
  | Compiler lhs.diag2pic = Compiler_ @c @l1 @l2 @m
  | Program lhs.diag2pic = Program_ @p @l
  | Execute lhs.diag2pic = Executed @d1 @d2
  | Compile lhs.diag2pic = Compiled @d1 @d2 (compile @d1)
-}
}

data Pic
    | Pic d :: Diag

attr Pic
  syn pic :: {Picture}

sem Pic
  | Pic lhs.pic = Picture @d.dim @d.cmd
         d.pos = (-100,snd @d.dim)
         d.blen = max @d.mlen 50 --50 is the minimum size


attr Diag Diag_
    syn diag :: self
    syn diag' :: {(Diag_)}
    syn cmd use {++} {[]} :: {[Command]}
    syn dim :: {(Double,Double)}
    syn dinfo :: {(DiagInfo)}
    syn h :: {Double}
    syn cjoint :: {(Double,Double)}
    syn endpt :: {(Double,Double)}
    syn depth :: {Double}
    syn tlen :: {(Double)}
    syn mlen :: {(Double)}
    inh blen :: {(Double)}
    inh pos :: {(Double,Double)}


sem Diag_
    | Platform lhs.cmd = platform @lhs.pos @lhs.blen @m
               lhs.diag' = @diag
               lhs.mlen = maxLength @diag
               lhs.h = 30
               lhs.tlen = 42.5
               lhs.dim = dimension @diag @lhs.blen
               lhs.dinfo = diagInfo Plat @lhs.blen
               lhs.depth = 0
               lhs.cjoint = cJoint Plat @lhs.pos @lhs.blen
               lhs.endpt = (fst @lhs.pos + 50, snd @lhs.pos + 30)
    | Program lhs.cmd = program @lhs.pos @lhs.blen @p @l
              lhs.diag' = @diag
              lhs.mlen = maxLength @diag
              lhs.h = 30
              lhs.tlen = 50
              lhs.dim = dimension @diag @lhs.blen
              lhs.dinfo = diagInfo Prog @lhs.blen
              lhs.depth = 0
              lhs.cjoint = cJoint Prog @lhs.pos @lhs.blen
              lhs.endpt = (fst @lhs.pos + 50, snd @lhs.pos + 30)
    | Interpreter lhs.cmd = interpreter @lhs.pos @lhs.blen @i @l @m
                  lhs.diag' = @diag
                  lhs.mlen = maxLength @diag
                  lhs.h = 30
                  lhs.tlen = 50
                  lhs.dim = dimension @diag @lhs.blen
                  lhs.dinfo = diagInfo Interp @lhs.blen
                  lhs.depth = 0 
                  lhs.cjoint = cJoint Interp @lhs.pos @lhs.blen
                  lhs.endpt = (fst @lhs.pos + 50, snd @lhs.pos + 30)
    | Compiler lhs.cmd = compiler @lhs.pos @lhs.blen @c @l1 @l2 @m
               lhs.diag' = @diag
               lhs.mlen = maxLength @diag
               lhs.h = 30
               lhs.tlen = 100
               lhs.dim = dimension @diag @lhs.blen
               lhs.dinfo = diagInfo Comp @lhs.blen
               lhs.depth = 0
               lhs.cjoint = cJoint Comp @lhs.pos @lhs.blen
               lhs.endpt = (fst @lhs.pos + 100, snd @lhs.pos + 30)
    | Execute lhs.cmd = @d1.cmd ++ @d2.cmd
              lhs.diag' = @d2.diag'
              d1.pos = @lhs.pos
              d2.pos = sumTuple @lhs.pos (ejoint @d1.dinfo)
              lhs.mlen = max @d1.mlen @d2.mlen
              d1.blen = @lhs.blen
              d2.blen = @lhs.blen
              lhs.h = @d1.h + @d2.h
              lhs.tlen = @d1.tlen + @d2.tlen
              lhs.dim = joinDimensions @diag @d1.dim @d2.dim
              lhs.dinfo = @d2.dinfo
              lhs.depth = max @d1.depth @d2.depth
              lhs.cjoint = @d2.cjoint
              lhs.endpt = @d2.endpt
    | Compile loc.cpos = rightPos @loc.cmpl (fst @loc.d1pos + @d1.tlen, snd @loc.d1pos) 50
              loc.cmpl = compile (dtd_ @d1.diag) (dtd_ @d2.diag)
              lhs.cmd = @d1.cmd ++ @d2.cmd ++ compiled @loc.cmpl @loc.cpos @lhs.blen
              lhs.diag' = @d1.diag'
              loc.d1pos = d1Pos @d1.depth @d2.depth @lhs.pos @d2.tlen (clen @d1.dinfo)
              loc.d2pos = d2Pos @d2.depth @d1.depth @lhs.pos @d1.tlen (cjoint @d1.dinfo)
              d1.pos = @loc.d1pos
              d2.pos = @loc.d2pos
              lhs.mlen = max @d1.mlen @d2.mlen
              d1.blen = @lhs.blen
              d2.blen = @lhs.blen
              loc.h = @d1.h + @d2.h - 10
              lhs.h = @d1.h
              lhs.tlen = @d1.tlen + 150 + @lhs.blen
              loc.dim = (joinDimensions @diag (fst @d1.dim, @d1.h) @d2.dim)
              lhs.dim = (fst $ joinDimensions @diag (dimension @loc.cmpl @lhs.blen) @loc.dim, snd @loc.dim)
              lhs.dinfo = translateDiagInfo @d1.dinfo (translatePos @d1.dinfo)
              lhs.depth = 1 + max @d1.depth @d2.depth
              loc.cjoint = cJoint Interp @loc.cpos @lhs.blen
              lhs.cjoint = @loc.cjoint
              lhs.endpt = endPt @loc.cmpl @loc.cpos @lhs.blen


{
--
--compilationPos @d2.diag @lhs.pos @d2.tlen (clen @d1.dinfo)
--compileWithPos @d2.diag @lhs.pos (cjoint @d1.dinfo) @lhs.blen
d1Pos :: Depth -> Depth -> Pos -> TotalLength -> CompLength -> Pos
d1Pos d1 d2 (x,y) tlen clen
  | diff >= 0 = (x,y)
  | otherwise = (x + tlen - 150, y + 20)
  where
    diff = d1 - d2

d2Pos :: Depth -> Depth -> Pos -> TotalLength -> Cjoint -> Pos
d2Pos d2 d1 (x,y) tlen (cx,cy)
  | diff > 0 = (x,y)
  | diff == 0 = (x + (abs diff * tlen) + cx, y + cy)
  | otherwise = (x + (abs diff * tlen), y + cy)
  where
    diff = d2 - d1


compilationPos :: Diag -> Pos -> TotalLength -> CompLength -> Pos
compilationPos (Diag _ (Compile _ _)) (x,y) tlen clen = (x + tlen - 150 - clen,y + 20)
compilationPos _ (x,y) _ _= (x,y)

compileWithPos :: Diag -> Pos -> Cjoint -> BlockLength -> Pos
compileWithPos (Diag _ (Compiler _ _ _ _)) (x,y) (cx,cy) blen = (x + cx,y + cy)
compileWithPos (Diag _ (Compile _ _)) (x,y) _ _ = (x,y)

mapTuple :: (a -> b) -> (a,a) -> (b,b)
mapTuple f (a1,a2) = (f a1, f a2)

sumTuple :: Num a => (a,a) -> (a,a) -> (a,a)
sumTuple (a1,a2) (b1,b2) = (a1 + b1, a2 + b2)

diagInfo :: DiagCons -> BlockLength -> DiagInfo
diagInfo Plat   blen = D Plat   30 blen blen  (0   ,0  ) (       0      ,   0)
diagInfo Interp blen = D Interp 30 blen blen  (0   ,-30) (    blen      , -20)
diagInfo Comp   blen = D Comp   30 (3*blen) (2*blen) (blen,-30) (2 * blen      , -20)
diagInfo prog   blen = D Prog   30 blen (blen + 7.5)  (7.5 ,-30) (    blen + 7.5, -20)

translatePos :: DiagInfo -> Pos
translatePos (D Comp _ _ _ _ _) = (0,0)
translatePos (D cons _ _ _ _ _) = (0,0)

translateDiagInfo :: DiagInfo -> Pos -> DiagInfo
translateDiagInfo (D c h l cl (ex,ey) (cx,cy)) (x,y) = 
    D c h l cl (ex + (x), ey + (y )) (cx + (x), cy + (y))

type Position = (Double,Double)

compLen :: Diag_ -> Double -> Double
compLen (Compiler _ _ _ _) len = len - 50
compLen _ len = len

wordLength :: String -> Double
wordLength s = fromIntegral (length s) * 5

maxLength :: Diag_ -> Double
maxLength (Platform m) = wordLength m
maxLength (Program p l) = max (wordLength p) (wordLength l)
maxLength (Interpreter i l m) = maximum [wordLength i, wordLength l, wordLength m]
maxLength (Compiler c l1 l2 m) = maximum [wordLength c, wordLength l1, wordLength l2, wordLength m]

dimension :: Diag_ -> Double -> (Double, Double)
dimension (Platform _) len = (len, 30)
dimension (Program _ _) len = (len + 15, 30)
dimension (Interpreter _ _ _) len = (len, 30)
dimension (Compiler _ _ _ _) len = (len * 3, 30)
dimension _ _ = (0,0)

joinDimensions :: Diag_  -> (Double, Double) -> (Double, Double) -> (Double, Double)
joinDimensions (Execute _ _) (x1,y1) (x2,y2) = (max x1 x2, y1 + y2)
joinDimensions (Compile _ _) (x1,y1) (x2,y2) = (x1 + x2, y1 + y2 - 10)

--These are necessary, because we need to determine the ejoint and cjoint of the compiled
--diag, but as we then do not know what diag it is we have to do pattern matching.
eJoint :: DiagCons -> Pos -> BlockLength -> Ejoint
eJoint Prog   (x,y) _    = (x + 7.5 , y - 30)
eJoint Interp (x,y) _    = (x       , y - 30)
eJoint Comp   (x,y) blen = (x + blen, y - 30)

cJoint :: DiagCons -> Pos -> BlockLength -> Cjoint
cJoint Prog   (x,y) blen = (x +      blen + 7.5, y - 20)
cJoint Interp (x,y) blen = (x +      blen      , y - 20)
cJoint Comp   (x,y) blen = (x + (2 * blen)     , y - 20)

endPt :: Diag_ -> Pos -> BlockLength -> (Double,Double)
endPt (Program _ _) (x,y) blen = (x + blen + 7.5, y - 30)
endPt (Interpreter _ _ _) (x,y) blen = (x + blen, y - 30)
endPt (Compiler _ _ _ _) (x,y) blen = (x + 100, y - 30)

rightPos :: Diag_ -> Position -> Double -> Position
rightPos (Program _ _) (x, y) len = (x + (len * 3), y)
rightPos (Interpreter _ _ _) (x, y) len = (x + (len * 3), y)
rightPos (Compiler _ _ _ _) (x, y) len = (x + (len * 2), y)

dtd_ :: Diag -> Diag_
dtd_ (Diag p d) = d

--First we still have to do some translation
compile :: Diag_ -> Diag_ -> Diag_
compile dg (Compile d1 d2) = compile dg (compile (dtd_ d1) (dtd_ d2))
compile (Program p _) (Compiler _ _ t _) = Program p t
compile (Interpreter i l _) (Compiler _ _ t _) = Interpreter i l t
compile (Compiler c l1 l2 _) (Compiler _ _ t _) = Compiler c l1 l2 t
compile (Execute d1 d2) dg = compile (dtd_ d2) dg
compile (Compile d1 d2) dg = compile (compile (dtd_ d1) (dtd_ d2)) dg
compile d1 _ = d1

--Given the translated diag and a position, convert it to a list of commands
compiled :: Diag_ -> (Double, Double) -> Double -> [Command]
compiled (Program p l) pos len = program pos len p l
compiled (Interpreter i l m) pos len = interpreter pos len i l m
compiled (Compiler c l1 l2 t) pos len = compiler pos len c l1 l2 t
compiled _ _ _= []

platform :: (Double, Double) -> Double -> String -> [Command]
platform (x,y) len m = [
            Put (x, y - 15) $ Line (5, -3) 25,
            Put (x + len / 2,y - 30) $ Line (5, 3) 25,
            Put (x, y - 15) $ Line (0, 1) 15,
            Put (x, y)  $ Line (1, 0) 50,
            Put (x + len, y) $ Line (0,-1) 15,
            Put (x, y - 15) $ Makebox (50, 15) m
        ]

program ::  (Double, Double) -> Double -> String -> String -> [Command]
program (x,y) len p l = [
                Put (x + 7.5, y - 30) $ Line (1,0) len,
                Put (x + 7.5, y - 30) $ Line (0,1) 15,
                Put (x + 7.5, y - 15) $ Line (-1, 2) 7.5,
                Put (x + len + 7.5, y - 15) $ Line (1, 2) 7.5,
                Put (x + len + 7.5, y - 30) $ Line (0,1) 15,
                Put (x, y) $ Line (1,0) (len + 15),
                Put (x + 7.5, y - 15) $ Makebox (len, 15) p,
                Put (x + 7.5, y - 30) $ Makebox (len, 15) l
            ]


interpreter :: (Double, Double) -> Double -> String -> String -> String -> [Command]
interpreter (x,y) len i l m = [ 
                        Put (x, y - 30) $ Framebox (len, 30) "", 
                        Put (x, y - 10) $ Makebox (len, 10) i,
                        Put (x, y - 20) $ Makebox (len, 10) l,
                        Put (x, y - 30) $ Makebox (len,10) m
                    ]

compiler :: (Double, Double) -> Double -> String -> String -> String -> String -> [Command] 
compiler (x,y) len c l1 l2 m = [
                        Put (x + len, y - 30) $ Line (0, 1) 20,
                        Put (x + len, y - 10) $ Line (-1, 0) len,
                        Put (x, y - 10) $ Line (0, 1) 10,
                        Put (x, y) $ Line (1, 0) (3 * len),
                        Put (x + (3 * len), y) $ Line (0,-1) 10,
                        Put (x + (3 * len), y - 10) $ Line (-1,0) len,
                        Put (x + (2 * len), y - 10) $ Line (0,-1) 20,
                        Put (x + (2 * len), y - 30) $ Line (-1, 0) len,
                        Put (x, y - 10) $ Makebox (len,10) l1,
                        Put (x + len, y - 10) $ Makebox (len,10) "$\\longrightarrow$",
                        Put (x + (2 * len), y - 10) $ Makebox (len,10) l2,
                        Put (x + len, y - 20) $ Makebox (len,10) c,
                        Put (x + len, y - 30) $ Makebox (len,10) m
                    ]


}
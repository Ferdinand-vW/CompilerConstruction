Compiler Construction Project E Code generation for a lazy functional language

Ferdinand van Walree 3874389 and Matthew Swart 5597250

This project uses the following compiler verions:
- Haskell version: 7.10.2-a
- uuagc-0.9.52.1
- uhc-light
To build the package it is necessary to follow the following instructions:
- Go to the root directory in a bash console;
- Type in the console "./Build.sh".

We have choosen to implement special builtin syntax to deal with the following features:
-   Bool: True and False
-   List: cons and nil, you can make a list by typing: "cons 1 (cons 2 nil)".
-   isCons; this function checks if it a cons
-   isNil; This function checks if the type is nil
-   head; This function will result into the head of a list. For example head (cons 1 (cons 2 nil)) results in 1.
-   tail; This function will result into the tail of a list. For example tail (cons 1 (cons 2 nil)) results in 1[2,0[]]
-   prim; This keyword allows you to use features from corerun. You can use the following feature: "primAddInt", "primSubInt", "primEqINt"

Futhermore, it is possible to use the following sysntax:
prim <name> <var1> <var2>
let <name> '=' "value" in <expr> ni
if <expr> then <value1> else <value2> fi
nil
cons

To see how the language looks like you can look at the "examples" directory in the root, which contains several examples on how to use the language. 
To compile the examples, run the "compile.sh" to compile the examples. It is also possible 


Technical explanation
This section gives an overview about the technical implemenentation of our solution. For a more detailed explanation we recommenend you to read the code and the comments that we added into all of the files. 

First we added the "AG" directory in the CCO folder to get a general location for all of the datatype that are used to compile the language. Then we moved the Core.ag and the HM.ag to that folder, And added AHM.ag to the directory. AHM.ag looks like hm.ag, but we omited the pos from it, because we did not use it. We use AHM datatype to transform the HM file into an aNormal form. 

Secondly, we added into "src/ParserHM.hs" the hm2cr function, which transforms the the Tm to an ANormal form. It uses the "src/CCO/HM/AG/ToANormal.ag" file to do this.

Then we added the "src/hm2cr.hs" file. This file uses the "src/Core/AG/Hm2Cr.ag" file to transform the AHM to a EXP. We divided the code in HM2Cr in several files to make it more readable. The first functions we added to a seperate file were the function that apply operations on an Env map. In that map we store the Reff. We added all of these function in the "src/CCO/Core/Ag/EnvMap.ag". Second category are the buildin functions. You can find them in "src/CCO/Core/Ag/BuildIn.ag". All of the other functions for transforming to an EXp are in the HM2Cr.ag file.


Notes
Unfortunately, due lack of time we did not implemenent lazy evaluation into the language. Also we could not get the "take" function provided in the assignment pdf working, however the sum is working. So, the recursion is partially working.


attr Tm Tm_
    syn tm :: ATm

sem Tm
    | Tm lhs.tm = @t.tm

sem Tm_
    | Nat   lhs.tm = ANat @i 
    | Var   lhs.tm = AVar @x
    | Prim  lhs.tm = APrim @f @t1.tm @t2.tm
    | Lam   lhs.tm = ALam @x @t1.tm
    | App   lhs.tm = removeDup [] $ transform (AApp @t1.tm @t2.tm)
    | Let   lhs.tm = ALet @x @t1.tm @t2.tm
    | If    lhs.tm = AIf @exp.tm @t1.tm @t2.tm
{

removeDup :: [String] -> ATm -> ATm
removeDup env (ALet x t1 t2)
    | x `elem` env = removeDup env t2
    | otherwise    = ALet x t1 $ removeDup (x:env) t2
removeDup _ tm = tm

eitherAApp :: ATm -> ATm -> Bool
eitherAApp (AApp _ _) _ = True
eitherAApp _ (AApp _ _) = True
eitherAApp _ _ = False

transform :: ATm -> ATm
transform (AApp (ALet x lt1 lt2) t2) = ALet x lt1 $ transform $ AApp lt2 t2
transform (AApp t1 (ALet x rt1 rt2)) = ALet x rt1 $ transform $ AApp t1 rt2
transform tm = newLets tm

newLets :: ATm -> ATm
newLets (AApp (AApp lt1 lt2) t2) = 
        ALet (letName lt1 lt2) (AApp lt1 lt2) $ newLets $
            AApp (AVar $ letName lt1 lt2) t2
newLets (AApp t1 (AApp rt1 rt2)) =
         ALet (letName rt1 rt2) (AApp rt1 rt2) $ newLets $
            AApp t1 $ AVar $ letName rt1 rt2
newLets tm = tm

getName :: ATm -> String
getName (ANat i) = show i
getName (APrim x _ _) = x
getName (AVar x) = x
getName (ALam x _) = x
getName (ALet x _ _) = x
getname _ = ""

letName :: ATm -> ATm -> String
letName tm1 tm2 = (getName tm1) ++ (getName tm2)

}
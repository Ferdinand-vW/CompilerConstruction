attr Tm Tm_
    syn tm_ :: Tm_
    inh previousTm :: Tm_

attr Tm
    syn tm :: Tm

sem Tm
    | Tm lhs.tm = Tm @pos @t.tm_

sem Tm_
    | HNat  lhs.tm_ = HNat @i
    | HVar  lhs.tm_ = HVar @x
    | HLam  lhs.tm_ = HLam @x @t1.tm
    | HApp  lhs.tm_ = HApp (functie @t1.tm_ @t1.tm) @t2.tm 
            t2.previousTm = @t1.tm_
    | HLet  lhs.tm_ = HLet @x @t1.tm @t2.tm


{

functie :: Tm_ -> Tm -> Tm
functie x y = y

translate :: Tm_ -> Tm_ -> Tm_
translate (HVar x) (HVar y) | x==y = HVar "Matthew"
                          | otherwise = (HVar x)
translate x y = x


--Ik krijg het niet correct werkend met uuagc-.-, dus zal wel de stappen opschrijven wat ik van plan was. Ik ben ook nog wel op skype denk ik.
--Controleer HApp of @t2 een HApp is
--Als dit zo is; controleer of @t1 en bij de eerste tm van @t2, dus @t2.t1, allebei een var zijn en gelijk aan elkaar zijn.
-- Als dit zo is voeg een HLet  toe met de naam @t1 ++ @t2.t2 (Als dit een var is). En doe de HApp als waarde
-- Vervolgens in de in van de let @t1 ++ @t2.t2 doe je HApp met @t1 (@t1 ++ @t2.t2)


-- 
}
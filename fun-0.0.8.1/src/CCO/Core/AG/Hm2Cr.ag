imports
{
import Data.Maybe
}

data Core
    | Core tm :: ATm

attr Core
    syn core :: {Mod}

sem Core
    | Core  lhs.core = Mod (SExp (Var @tm.main)) (defaultBinds ++ @tm.binds)
            tm.genv = (8,[("True", Glob 7),("False", Glob 6),("isNil", Glob 5),("isCons", Glob 4),("tail", Glob 3),("head", Glob 2),("cons", Glob 1),("nil",Glob 0)])
            tm.lenv = (0,[])
            tm.lvl = 0
            tm.args = 0

attr ATm
    syn tm :: self
    syn main :: {Ref}
    syn exp :: {Exp}
    syn binds use {++} {[]} :: {BindL}
    inh genv :: {Map String Ref}
    inh lenv :: {Map String Ref}
    inh lvl :: {Int}
    inh args :: {Int}

sem ATm
    |   ANat lhs.main = next @lhs.genv
              lhs.exp  = natExp @i
              lhs.binds = [Bind (next @lhs.genv) $ Lam [] $ natExp @i]
    |   AVar lhs.main = next @lhs.genv
             lhs.exp  = varExp @lhs.genv @lhs.lenv @x
              lhs.binds = [Bind (next @lhs.genv) $ Lam [] $ varBind @lhs.genv @x]

{
natExp :: Int -> Exp
natExp i = SExp $ Int i

varExp :: Map String Ref -> Map String Ref -> String -> Exp
varExp genv lenv s = SExp $ findVarRef genv lenv s

varBind :: Map String Ref -> String -> Exp
varBind genv s = Eval $ SExp $ findVarRef' genv s

--First looks for the Ref in the local environment, if it cannot find it, then
--it will check the global environment. If it wasn't found, then the program crashes
findVarRef :: Map String Ref -> Map String Ref -> String -> SExp
findVarRef (_,genv) (_,lenv) s = Var $ fromMaybe (fromJust (lookup s genv))  (lookup s lenv)

--Same as findVarRef except for just a single environment
findVarRef' :: Map String Ref -> String -> SExp
findVarRef' (_,env) s = Var $ fromJust $ lookup s env

toSExp :: Exp -> SExp
toSExp (SExp s) = s
}


sem ATm
    |   ANil  lhs.main = next @lhs.genv
              lhs.exp = SExp $ findVarRef' @lhs.genv "nil"
              lhs.binds = [Bind (next @lhs.genv) $ nilBind' @lhs.genv]
    |   ACons lhs.main = next @lhs.genv
              lhs.exp = mkCons @lhs.genv (0,[]) (ACons @t1.tm @t2.tm)
              lhs.binds = [Bind (next @lhs.genv) $ mkCons @lhs.genv (0,[]) (ACons @t1.tm @t2.tm)]

{

nilBind' :: Map String Ref -> Exp
nilBind' genv = SExp $ findVarRef' genv "nil"

mkCons :: Map String Ref -> Map String Ref -> ATm -> Exp
mkCons genv lenv atm = consExp genv offset atm (SExp $ Var $ Loc 0 offset)
  where
    offset = getOffSet lenv + (listLength atm) - 1

consExp :: Map String Ref -> Int -> ATm -> Exp -> Exp
consExp genv n (ACons t1 t2) t3 = case t2 of
                            ACons _ _ -> consExp genv (n-1) t2 (Let (Bind curr (App cons [toInt t1,Var prev])) t3)
                            ANil -> Let (Bind curr (App cons [toInt t1, nil])) t3
      where
        cons = SExp $ findVarRef' genv "cons"
        nil = findVarRef' genv "nil"
        curr = Loc 0 n
        prev = Loc 0 (n - 1)
        toInt (ANat n) = Int n

listLength :: ATm -> Int
listLength (ACons _ l) = 1 + listLength l
listLength _ = 0

}


sem ATm
    |   ALam  lhs.main = next @lhs.genv
              lhs.exp  = joinLam [Loc (0) $ 0] @t1.exp
              lhs.binds = []
              t1.genv = @lhs.genv
              t1.lenv = updateEnv @lhs.lenv @lhs.args @x
              t1.lvl = @lhs.lvl + 1
              t1.args = 1 + @lhs.args
{

--Consecutive lambda's are joined
joinLam :: RefL -> Exp -> Exp
joinLam xs (Lam ys t1) = Lam (xs ++ ys) t1
joinLam xs exp = Lam xs exp

updateEnv :: Map String Ref -> Int -> String -> Map String Ref
updateEnv lenv numArgs s = insertl' (newOffSet lenv (numArgs)) s (Loc 0 numArgs)

}


sem ATm
    |   AApp lhs.main = next @lhs.genv
              lhs.exp = appExp @lhs.lenv @t1.exp @t2.exp
              lhs.binds = [Bind (Glob (getOffSet @lhs.genv)) (Lam [] $ appExp @lhs.lenv @t1.exp @t2.exp)]
              t1.genv = @lhs.genv
              t2.genv = @lhs.genv
              t1.lenv = @lhs.lenv
              t2.lenv = @lhs.lenv
              t1.lvl = @lhs.lvl
              t2.lvl = @lhs.lvl

{
appExp' :: Map String Ref -> Exp -> Exp -> Exp
appExp' lenv exp (Let b exp2) = Lam [] (appExp lenv exp (Let b exp2))
appExp' lenv exp exp2 = appExp lenv exp exp2

appExp :: Map String Ref -> Exp -> Exp -> Exp
appExp lenv exp (Let b exp2) = Let b (appExp lenv exp exp2)
appExp lenv (SExp sexp1) (SExp sexp2) = Let (Bind (Loc 0 $ getOffSet lenv) (Eval (SExp sexp2))) (
                                Let (Bind (Loc 0 $ getOffSet lenv + 1) (Eval (SExp sexp1))) $ 
                                    App (SExp $ Var $ Loc 0 (getOffSet lenv + 1)) [Var $ Loc 0 (getOffSet lenv)])


}

sem ATm
    |   ALet lhs.main = @t2.main
              lhs.exp  = letExp @lhs.genv @t1.exp @t2.exp--Let (Bind (next @lhs.genv) @t1.exp) @t2.exp
              lhs.binds = letBinds @lhs.genv @t1.tm @t1.exp @t2.binds
              t1.genv = @lhs.genv
              loc.genv = globalLet @lhs.genv @lhs.lvl @x
              t2.genv = @loc.genv
              t1.lenv = incrEnv @lhs.lenv
              t2.lenv = localLet @lhs.lenv @lhs.lvl @x
              t1.lvl = localLetLvl @lhs.lvl
              t2.lvl = @lhs.lvl
              t1.args = 0
              t2.args = 0

{
globalLet :: Map String Ref -> Int -> String -> Map String Ref
globalLet genv lvl x 
  | lvl == 0 = insertg genv x
  | otherwise = genv

localLetLvl :: Int -> Int
localLetLvl 0 = 1
localLetLvl lvl = lvl

localLet :: Map String Ref -> Int -> String -> Map String Ref
localLet lenv lvl x
  | lvl > 0 = insertl lenv x
  | otherwise = lenv

letExp :: Map String Ref -> Exp -> Exp -> Exp
letExp genv (Let b t1) exp2 = Let (Bind (next genv) (Lam [] (Let b t1))) exp2
letExp genv exp exp2 = Let (Bind (next genv) exp) exp2

letBinds :: Map String Ref -> ATm -> Exp -> BindL -> BindL
letBinds (n,_) (ALam _ _) exp t2binds = Bind (Glob n) exp : t2binds
letBinds (n,_) _ exp t2binds = Bind (Glob n) (Lam [] exp) : t2binds
}

sem ATm
    |   APrim lhs.main = next @lhs.genv
              lhs.exp = Prim @f [toPrim @t1.exp, toPrim @t2.exp]
              lhs.binds = []
              t1.genv = @lhs.genv
              t2.genv = @lhs.genv
              t1.lenv = @lhs.lenv
              t2.lenv = @lhs.lenv

{
toPrim :: Exp -> SExp
toPrim (SExp s) = Var $ Loc 0 (off s)
              where off (Var (Loc l o)) = o  
}

sem ATm
    |   AIf lhs.main = Glob (getOffSet @lhs.genv)
              lhs.exp = createCase @exp.exp @loc.exp
              loc.exp = Case (Var $ Tag $ Loc 0 $ getOffSet @lhs.lenv) [@t2.exp, @t1.exp]
              lhs.binds = []
              t1.genv = @lhs.genv
              t2.genv = @lhs.genv
              t1.lenv = incrOffSet' @lhs.lenv 1
              t2.lenv = incrOffSet' @lhs.lenv 1
              t1.lvl = @lhs.lvl
              t2.lvl = @lhs.lvl
              t1.args = 0
              t2.args = 0
{

createCase :: Exp -> Exp -> Exp
createCase e1@(SExp s) e2 = Let (Bind (getRef s) (Eval e1)) e2

getRef :: SExp -> Ref
getRef (Var x) = x
getRef _ = error "It did not solve"

incrOffSet' :: Map String Ref -> Int -> Map String Ref
incrOffSet' (n,xs) i = (n + i, xs)

checkIf :: ATm -> Exp -> Exp
checkIf (AIf _ _ _) (Lam a s)  = s
checkIf _ e = e

joinAppValue :: Exp -> Exp -> Exp
joinAppValue (Let (Bind r t1) t2) exp2 = Let (Bind r (joinParentAppValue t1 t2)) exp2

joinChildAppValue :: Exp -> SExpL
joinChildAppValue (App x y) = y
joinChildAppValue (SExp x) = [x]
joinChildAppValue (Let x y) = joinChildAppValue y --Hier gaat het verkeerd

joinParentAppValue :: Exp -> Exp -> Exp
joinParentAppValue (App x y) app2 = App x (y ++ joinChildAppValue app2)
}
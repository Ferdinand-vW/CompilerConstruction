imports
{
import Data.Maybe
}

{
type Map a b = (Int, [(a,b)])

}


data Core
    | Core tm :: ATm

attr Core
    syn core :: {Mod}

sem Core
    | Core  lhs.core = Mod (SExp (Var @tm.main)) @tm.binds
            tm.genv = (0,[])
            tm.lenv = (0,[])

--("False",Glob 0) ("True", Glob 1)
attr ATm
    syn tm :: self
    syn main :: {Ref}
    syn exp :: {Exp}
    syn binds use {++} {[]} :: {BindL}
    inh genv :: {Map String Ref}
    inh lenv :: {Map String Ref}

sem ATm
    |   ANat lhs.main = Glob (getOffSet @lhs.genv)
              lhs.exp  = SExp (Int @i)
              lhs.binds = [Bind (Glob (getOffSet @lhs.genv)) (SExp (Int @i))]
    |   AVar lhs.main = Glob (getOffSet @lhs.genv)
             lhs.exp  = SExp $ findVarRef @lhs.genv @lhs.lenv (AVar @x)
              lhs.binds = [Bind (Glob (getOffSet @lhs.genv)) (SExp $ findVarRef @lhs.genv @lhs.lenv (AVar @x))]
    |   ALam  lhs.main = Glob (getOffSet @lhs.genv)
              lhs.exp  = joinLam [Loc 0 $ getOffSet @lhs.lenv] @t1.exp --Hard coded lvl as 0 for now
              lhs.binds = []
              t1.genv = @lhs.genv
              t1.lenv = insertl @lhs.lenv 0 @x
    |   AApp lhs.main = Glob (getOffSet @lhs.genv)
              lhs.exp  = App (@t1.exp) [fromExp @t2.exp]
              lhs.binds = [Bind (Glob (getOffSet @lhs.genv)) (App (@t1.exp) [fromExp @t2.exp])]
              t1.genv = @lhs.genv
              t2.genv = @lhs.genv
              t1.lenv = @lhs.lenv
              t2.lenv = @lhs.lenv
    |   ALet lhs.main = @t2.main
              lhs.exp  = Let (Bind (Glob (getOffSet @lhs.genv)) @t1.exp) @t2.exp
              lhs.binds = Bind (Glob (getOffSet @lhs.genv)) @t1.exp : @t2.binds
              t1.genv = @lhs.genv
              t2.genv = insertg @lhs.genv @x
              t1.lenv = @lhs.lenv
              t2.lenv = @lhs.lenv
    |   APrim lhs.main = Glob (getOffSet @lhs.genv)
              lhs.exp = Prim @f [fromPrim @t1.exp, fromPrim @t2.exp]
              lhs.binds =  []
              t1.genv = @lhs.genv
              t2.genv = @lhs.genv
              t1.lenv = @lhs.lenv
              t2.lenv = @lhs.lenv
    |   AIf lhs.main = Glob (getOffSet @lhs.genv)
              lhs.exp = Lam [] (joinAppValue @exp.exp @loc.exp)
              loc.exp = Case (Var $ Tag 0 $ getOffSet @lhs.lenv) [checkIf @t2.tm @t2.exp, checkIf @t1.tm @t1.exp]
              lhs.binds =  []
              t1.genv = @lhs.genv
              t2.genv = @lhs.genv
              t1.lenv = ((fst @lhs.lenv)+1, snd @lhs.lenv)
              t2.lenv = ((fst @lhs.lenv)+1, snd @lhs.lenv)
{

checkIf :: ATm -> Exp -> Exp
checkIf (AIf _ _ _) (Lam a s)  = s
checkIf _ e = e

joinAppValue :: Exp -> Exp -> Exp
joinAppValue (Let (Bind r x) y) exp2 = Let (Bind r (joinParentAppValue x y)) exp2
joinChildAppValue :: Exp -> SExpL
joinChildAppValue (App x y) = y
joinChildAppValue (SExp x) = [x]
joinChildAppValue (Let x y) = joinChildAppValue y --Hier gaat het verkeerd
joinParentAppValue :: Exp -> Exp -> Exp
joinParentAppValue (App x y) app2 = App x (y ++ joinChildAppValue app2)

joinLam :: RefL -> Exp -> Exp
joinLam xs (Lam ys t1) = Lam (xs ++ ys) t1
joinLam xs exp = Lam xs exp

fromExp :: Exp -> SExp
fromExp (SExp s) = s

fromPrim :: Exp -> SExp
fromPrim (SExp s) = Var $ Loc 0 (off s)
              where off (Var (Loc l o)) = o


findVarRef :: Map String Ref -> Map String Ref -> ATm -> SExp
findVarRef (_,genv) (_,lenv) (AVar x) = Var $ fromMaybe (fromJust (lookup x genv)) (lookup x lenv)

getOffSet :: Map String Ref -> Int
getOffSet (x,_) = x

insertg :: Map String Ref -> String -> Map String Ref
insertg (n,xs) s = (n+1,(s, Glob $ n) : xs)

insertl :: Map String Ref -> Int -> String -> Map String Ref
insertl (n,xs) lvl s = (n+1,(s, Loc lvl $ n) : xs)
}
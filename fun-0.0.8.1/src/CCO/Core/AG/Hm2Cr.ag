imports
{
import Data.Maybe
}

{
type Map a b = [(a,b)]
}


data Core
    | Core tm :: ATm

attr Core
    syn core :: {Mod}

sem Core
    | Core  lhs.core = Mod (SExp (Var @tm.main)) @tm.binds
            tm.genv = []
            tm.lenv = []

attr ATm
    syn tm :: self
    syn main :: {Ref}
    syn exp :: {Exp}
    syn binds use {++} {[]} :: {BindL}
    inh genv :: {Map String Ref}
    inh lenv :: {Map String Ref}

sem ATm
    |   ANat lhs.main = Glob (getOffSet @lhs.genv)
              lhs.exp  = SExp (Int @i)
              lhs.binds = []
    |   AVar lhs.main = Glob (getOffSet @lhs.genv)
             lhs.exp  = SExp $ findVarRef @lhs.genv @lhs.lenv (AVar @x)
              lhs.binds = []
    |   ALam  lhs.main = Glob (getOffSet @lhs.genv)
              lhs.exp  = joinLam [Loc 0 $ getOffSet @lhs.lenv] @t1.exp --Hard coded lvl as 0 for now
              lhs.binds = []
              t1.genv = @lhs.genv
              t1.lenv = insertl @lhs.lenv 0 @x
    |   AApp lhs.main = Glob (getOffSet @lhs.genv)
              lhs.exp  = App (@t1.exp) [fromExp @t2.exp]
              lhs.binds = [Bind (Glob (getOffSet @lhs.genv)) (App (@t1.exp) [fromExp @t2.exp])]
              t1.genv = @lhs.genv
              t2.genv = @lhs.genv
              t1.lenv = @lhs.lenv
              t2.lenv = @lhs.lenv
    |   ALet lhs.main = @t2.main
              lhs.exp  = Let (Bind (Glob (getOffSet @lhs.genv)) @t1.exp) @t2.exp
              lhs.binds = Bind (Glob (getOffSet @lhs.genv)) @t1.exp : @t2.binds
              t1.genv = @lhs.genv
              t2.genv = insertg @lhs.genv @x
              t1.lenv = @lhs.lenv
              t2.lenv = @lhs.lenv
    |   APrim lhs.main = Glob (getOffSet @lhs.genv)
              lhs.exp = Prim @f [fromPrim @t1.exp, fromPrim @t2.exp]
              lhs.binds =  []
              t1.genv = @lhs.genv
              t2.genv = @lhs.genv
              t1.lenv = @lhs.lenv
              t2.lenv = @lhs.lenv
{

joinLam :: RefL -> Exp -> Exp
joinLam xs (Lam ys t1) = Lam (xs ++ ys) t1
joinLam xs exp = Lam xs exp

fromExp :: Exp -> SExp
fromExp (SExp s) = s

fromPrim :: Exp -> SExp
fromPrim (SExp s) = Var $ Loc 0 (off s)
              where off (Var (Loc l o)) = o


findVarRef :: Map String Ref -> Map String Ref -> ATm -> SExp
findVarRef genv lenv (AVar x) = Var $ fromMaybe (fromJust (lookup x genv)) (lookup x lenv)

getOffSet :: Map String Ref -> Int
getOffSet xs = length xs

insertg :: Map String Ref -> String -> Map String Ref
insertg xs s = (s, Glob $ getOffSet xs) : xs

insertl :: Map String Ref -> Int -> String -> Map String Ref
insertl xs lvl s = (s, Loc lvl $ getOffSet xs) : xs
}
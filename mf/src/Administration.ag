include "AttributeGrammar.ag"

imports
{
import qualified Data.Map as M
import qualified Data.Set as S
import Data.Maybe
}

{


toProgramInfo :: Program -> ProgramInfo
toProgramInfo program = pinfo_Syn_Program $ wrap_Program (sem_Program program) (Inh_Program)

data ProgramInfo = ProgramInfo {blocks :: M.Map Label Block, labels :: [Label] , init :: [Label], finals :: [Label], 
                                flow :: Flow, interflow :: InterFlow, vars :: [Var]} deriving (Show)

data Block = 
    B_IAssign {name :: String, valI :: IExpr} |
    B_BAssign {name :: String, valB :: BExpr} |
    B_Cond {cond :: BExpr} |
    B_Skip |
    B_CallEntry {name :: String, params :: Exprs, pArgs :: [Var], pOut :: Var} |
    B_CallExit  {name :: String, pArgs :: [Var], pOut :: String, cOut :: String} |
    B_ProcEntry |
    B_ProcExit
    deriving Show

type Label = Int
type Flow = [(Int, Int)]
type InterFlow = [(Int,Int,Int,Int)]
type Var = String
}

attr Program
     syn pinfo :: ProgramInfo

sem Program 
    | Program lhs.pinfo = ProgramInfo @loc.blocks [1 .. @stat.maxLabel] [@stat.initl] (@stat.flabels) @loc.flow @loc.interflow (S.toList @loc.svars)
              loc.blocks = M.union @procs.blocks @stat.blocks
              loc.flow   = @procs.flow ++ @stat.flow
              loc.interflow = @procs.interflow ++ @stat.interflow
              loc.svars = S.union @procs.svars @stat.svars
              procs.label = 1
              stat.label = @procs.maxLabel + 1
              procs.prcs = M.empty
              stat.prcs = @procs.pmap
              procs.prgs = M.empty
              stat.prgs = @procs.pargs

attr Procs Proc Stat
    inh label :: {Label}
    syn maxLabel :: {Label}
    syn blocks :: {M.Map Label Block}
    inh prcs :: {M.Map String (Label,Label)}
    inh prgs :: {M.Map String ([Var],Var)}
    syn flow use {++} {[]} :: {Flow}
    syn interflow use {++} {[]} :: {InterFlow}

attr Stat
    syn flowLabels :: {[Label]}
    syn initl :: {Label}
    syn flabels :: {[Label]}

attr Procs Proc
    syn pmap :: {M.Map String (Label,Label)}
    syn pargs :: {M.Map String ([Var],Var)}

sem Procs
    | Cons hd.label = @lhs.label
           tl.label = @hd.maxLabel + 1
           lhs.maxLabel = @hd.maxLabel
           lhs.blocks   = M.union @hd.blocks @tl.blocks
           lhs.pmap     = M.union @hd.pmap @tl.pmap
           hd.prcs      = @lhs.prcs
           tl.prcs      = @hd.pmap
           lhs.pargs    = M.union @hd.pargs @tl.pargs
           hd.prgs     = @lhs.prgs
           tl.prgs      = @hd.pargs
           lhs.flow     = @hd.flow ++ @tl.flow
           lhs.interflow = @hd.interflow ++ @tl.interflow
           lhs.svars    = S.union @hd.svars @tl.svars
    | Nil  lhs.maxLabel = @lhs.label - 1
           lhs.blocks   = M.empty
           lhs.pmap     = M.empty
           lhs.pargs    = M.empty
           lhs.flow     = []
           lhs.interflow = []
           lhs.svars    = S.empty

sem Proc
    | Proc stat.label = @lhs.label + 1
           lhs.maxLabel = @stat.maxLabel + 1
           lhs.blocks   = M.union (M.union (M.singleton @lhs.label B_ProcEntry) (M.singleton (@stat.maxLabel + 1) B_ProcExit)) @stat.blocks
           loc.pmap     = M.singleton @name (@lhs.label,@stat.maxLabel + 1)
           lhs.pmap     = @loc.pmap
           stat.prcs    = @loc.pmap
           loc.prgs    = M.singleton @name (@inp,@out)
           lhs.pargs    = @loc.prgs
           stat.prgs   = @loc.prgs
           lhs.flow     = [(@lhs.label,@lhs.label + 1)] ++ @stat.flow ++ map (\x -> (x,@stat.maxLabel + 1)) @stat.flabels
           lhs.interflow = @stat.interflow
           lhs.svars    = S.union (S.union (foldr (\x y -> S.insert x y) S.empty @inp) (S.singleton @out)) @stat.svars


attr Procs Proc Exprs Expr IExpr BExpr Stat
    syn svars :: {S.Set Var}
    syn slf :: self

sem Stat
    | Skip       lhs.maxLabel  = @lhs.label
                 lhs.flowLabels = [@lhs.label]
                 lhs.blocks    = M.singleton @lhs.label B_Skip
                 lhs.svars     = S.empty
                 lhs.flow      = []
                 lhs.interflow = []
                 lhs.initl     = @lhs.label
                 lhs.flabels   = [@lhs.label]
    | IfThenElse lhs.maxLabel  = @stat2.maxLabel
                 lhs.flowLabels = [@loc.label1,@loc.label2]
                 lhs.flow      = (@lhs.label, @loc.label1) : (@lhs.label, @loc.label2) : @stat1.flow ++ @stat2.flow
                 lhs.interflow = @stat1.interflow ++ @stat2.interflow
                 stat1.label   = @loc.label1
                 loc.label1    = @lhs.label + 1
                 loc.label2    = @stat1.maxLabel + 1
                 stat2.label   = @loc.label2
                 lhs.blocks    = M.union (M.union (M.singleton @lhs.label (B_Cond @cond.slf)) @stat1.blocks) @stat2.blocks
                 lhs.svars     = S.union @cond.svars (S.union @stat1.svars @stat2.svars)
                 lhs.initl     = @lhs.label
                 lhs.flabels   = [@stat1.maxLabel,@stat2.maxLabel]
                 stat1.prcs    = @lhs.prcs
                 stat2.prcs    = @lhs.prcs
                 stat1.prgs   = @lhs.prgs
                 stat2.prgs   = @lhs.prgs
    | While      lhs.maxLabel  = @stat.maxLabel
                 lhs.flowLabels = [@lhs.label]
                 lhs.flow      = (@lhs.label, @loc.label1) : @stat.flow ++ map (\x -> (x,@lhs.label)) @stat.flabels
                 lhs.interflow = @stat.interflow
                 loc.label1    = @lhs.label + 1
                 stat.label    = @loc.label1
                 lhs.blocks    = M.union (M.singleton @lhs.label (B_Cond @cond.slf)) @stat.blocks
                 lhs.svars     = S.union @cond.svars @stat.svars
                 lhs.initl     = @lhs.label
                 lhs.flabels   = [@lhs.label]
                 stat.prcs     = @lhs.prcs
                 stat.prgs    = @lhs.prgs
    | IAssign    lhs.maxLabel  = @lhs.label
                 lhs.flowLabels = [@lhs.label]
                 lhs.blocks    = M.singleton @lhs.label $ B_IAssign @name @val.slf
                 lhs.svars     = S.union (S.singleton @name) @val.svars
                 lhs.flow      = []
                 lhs.interflow = []
                 lhs.initl     = @lhs.label
                 lhs.flabels   = [@lhs.label]
    | BAssign    lhs.maxLabel  = @lhs.label
                 lhs.flowLabels = [@lhs.label]
                 lhs.blocks    = M.singleton @lhs.label $ B_BAssign @name @val.slf
                 lhs.svars     = S.union (S.singleton @name) @val.svars
                 lhs.flow      = []
                 lhs.interflow = []
                 lhs.initl     = @lhs.label
                 lhs.flabels   = [@lhs.label]
    | Seq        lhs.maxLabel  = @stat2.maxLabel
                 lhs.flowLabels = @stat2.flowLabels
                 lhs.flow      = @stat1.flow ++ map (\x -> (x,@loc.label2)) @stat1.flowLabels ++ @stat2.flow
                 lhs.interflow = @stat1.interflow ++ @stat2.interflow
                 lhs.blocks    = M.union @stat1.blocks @stat2.blocks
                 stat1.label   = @lhs.label
                 loc.label2    = @stat1.maxLabel + 1
                 stat2.label   = @loc.label2
                 lhs.svars     = S.union @stat1.svars @stat2.svars
                 lhs.initl     = @lhs.label
                 lhs.flabels   = @stat2.flabels
                 stat1.prcs    = @lhs.prcs
                 stat2.prcs    = @lhs.prcs
                 stat1.prgs   = @lhs.prgs
                 stat2.prgs   = @lhs.prgs
    | Call       lhs.maxLabel  = @lhs.label + 1
                 lhs.flowLabels = [@lhs.label + 1]
                 lhs.flow      = [(@lhs.label , @loc.pInLabel), (@loc.pOutLabel,@lhs.label + 1)]
                 lhs.interflow = [(@lhs.label,@loc.pInLabel,@loc.pOutLabel,@lhs.label + 1)]
                 lhs.blocks    = M.union (M.singleton @lhs.label (B_CallEntry @name @params.slf @loc.pargs @loc.pout)) (M.singleton (@lhs.label + 1) (B_CallExit @name @loc.pargs @loc.pout @out))
                 lhs.initl     = @lhs.label
                 lhs.flabels   = [@lhs.label + 1]
                 lhs.svars     = S.union @params.svars (S.singleton @out)
                 loc.pInLabel  = fst $ fromJust $ M.lookup @name @lhs.prcs
                 loc.pOutLabel = snd $ fromJust $ M.lookup @name @lhs.prcs
                 loc.pargs     = fst $ fromJust $ M.lookup @name @lhs.prgs
                 loc.pout      = snd $ fromJust $ M.lookup @name @lhs.prgs

sem Exprs
    | Cons      lhs.svars = S.union @hd.svars @tl.svars
    | Nil       lhs.svars = S.empty

sem Expr
    | B         lhs.svars = @expr.svars
    | I         lhs.svars = @expr.svars

sem IExpr
    | IConst    lhs.svars = S.empty
    | Var       lhs.svars = S.singleton @name
    | Plus      lhs.svars = S.union @left.svars @right.svars
    | Minus     lhs.svars = S.union @left.svars @right.svars
    | Times     lhs.svars = S.union @left.svars @right.svars
    | Divide    lhs.svars = S.union @left.svars @right.svars

sem BExpr
    | BConst        lhs.svars = S.empty
    | BVar          lhs.svars = S.singleton @name
    | LessThan      lhs.svars = S.union @left.svars @right.svars
    | GreaterThan   lhs.svars = S.union @left.svars @right.svars
    | LessEqual     lhs.svars = S.union @left.svars @right.svars
    | GreaterEqual  lhs.svars = S.union @left.svars @right.svars
    | IEqual        lhs.svars = S.union @left.svars @right.svars
    | BEqual        lhs.svars = S.union @left.svars @right.svars
    | And           lhs.svars = S.union @left.svars @right.svars
    | Not           lhs.svars = @val.svars

{

--foldProcs :: Procs -> (Int, M.Map String Proc')
--foldProcs prcs = foldr (\x y -> 
                --let (l,proc') = wrapproc x (fst y)
                --in (l + 1,M.insert (getName proc') proc' $ snd y)) (1,M.empty) prcs

getName :: Proc' -> String
getName (Proc' _ _ name _ _ _) = name

--wrapproc :: Proc -> Int -> (Int, Proc')
--wrapproc proc label = main_Syn_Proc $ wrap_Proc (sem_Proc proc) (Inh_Proc label)
}